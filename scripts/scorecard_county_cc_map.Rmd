---
title: Mapping Earnings Data from College Scorecard
author: Will Doyle and Benjamin Skinner
output:
  html_document:
    theme: cosmo
---

<!--

PROJ: Analyzing new college score card data
AUTH: Will Doyle and Benjamin Skinner
INIT: 12 September 2015

-->

```{r header, warning = FALSE, message = FALSE, include = FALSE}
################################################################################
## HEADER INFORMATION
################################################################################

## read in strings as strings, not factors
options(stringsAsFactors = FALSE)

##  package list
libs <- c('dplyr',                 # make data wrangling easier
          'gstat',                 # kriging
          'geojsonio',             # to handle geojson data type
          'htmlwidgets',           # way to bind javascript libraries
          'knitr',                 # combine R code and markdown
          'leaflet',               # interactive mapping module
          'maptools',              # mapping projections
          'RColorBrewer',          # create color palettes
          'readr',                 # faster reading of large csv files
          'rgdal',                 # interact with gdal GIS framework
          'rgeos',                 # interact with geos GIS framework                
          'scales',                # Nicely formed scales
          'tidyr')                 # make data wrangling easier

## load packages
lapply(libs, require, character.only = T)

## set relative directory paths
ddir <- '../data/'
mdir <- '../map/'

## projection (do not change unless there's a specific reason)
proj <- CRS('+init=epsg:4269')

## add icon for schools
schoolIcon <- makeIcon(iconUrl = paste0(ddir, 'college-24.svg'),
                       iconWidth = 35, iconHeight = 35)

## set knitr global chunk options
knitr::opts_chunk$set(echo=FALSE,results='hide',warning=FALSE,message=FALSE)

```

```{r options}
################################################################################
## SET YEAR, SCORECARD, AND INSTITUTION VARIABLE OPTIONS
################################################################################

## Set the year for your map. You must have all relevelant files for
## the program to run

## year option
year <- 2011

## TODO: Three variables: earnigns of entrants, county earnings, earnings of entrants as a % of county earnings

## outcome column in addition to required
outcome <- 'md_earn_wne_p10'
var_describe <- 'Median earnings of attendees ten years later'

required <- c('unitid','instnm')
sccols <- c(required, outcome)

## REPORT CATEGORIES -----------------------------------------------------------
##
## 1 = Public Doctoral (includes extensive and intensive) 4-year
## 2 = Public Non-Doctoral (all other 4-years)
## 3 = Private Doctoral (as above)
## 4 = Private Non-Doctoral (as above)
## 5 = Public 2 year (>= 90% of degrees at Associateâ€™s or certificate level)
## 6 = Public Vocational/Technical
## 
## -----------------------------------------------------------------------------


## TODO: Generalize to ALL Institutions
## select category
instcat <- 5

```

```{r data}
################################################################################
## LOAD DATA
################################################################################

## load county shapefile (national level)
shapefile <- paste0('gz_2010_us_050_00_500k')

## read in college scorecard data
csdat <- read_csv(paste0(ddir, 'MERGED', year, '_PP.csv'), progress = FALSE)

## set mask based on columns set above
keep <- sapply(sccols, FUN = function(x) { grep(x, tolower(names(csdat))) })

## subset
csdat <- csdat %>% select(keep)

## read in IPEDS institution GEO files
inst_all <- read_csv(paste0(ddir, 'insts.csv'))

## get ACS
acs <- read_csv(paste0(ddir, 'acs_data.csv'))

##county layer

county_layer<-"gz_2010_us_050_00_500k"
```

```{r functions}
################################################################################
## FUNCTIONS
################################################################################

instPointsSpatial <- function(dat,                  # merged score data
                              outcome_var,          # outcome variable
                              proj,                 # projection to use
                              save.file = TRUE      # option to save result
                              ) {

    ## pop longitude and latitude from data frame
    dat <- dat %>% filter(!is.na(outcome_var))
    inst_points <- data.frame(dat %>% select(longitud,latitude))
    dat <- data.frame(dat %>% select(-latitude, -longitud))
    
    ## creates a spatial points data frame using long and lat from IPEDS
    inst_sp <- SpatialPointsDataFrame(coords = inst_points,
                                      data = dat, 
                                      proj4string = proj)

    ## save spatial data frame
    filename <- paste0(mdir, 'institutional_points.geojson')
    if(save.file) {
        geojson_write(inst_sp, file = filename)
    }
    
    ## return
    return(inst_sp)
}

krigeMap <- function(ddir,                          # data directory
                     dat,                           # merged scorecard data
                     inst_sp,                       # institution spatial
                     acsdat,                        # acs data
                     outcome_var,                   # variable to krige
                     select_group,                  # which colleges to use
                     sf,                            # shapefile 
                     proj = CRS('+init=epsg:4269'), # projection to use
                     save.file = TRUE               # option to save result
                     ) {

    ## ////////////////////////////////////////////////////////////////////
    ## This function will krige the outcome data and return a spatial
    ## object with the proper data. It takes a long time to run so it
    ## defaults to save the output, which can then be called the next time.
    ## The save may be overwritten by switching save.file to FALSE.
    ## ////////////////////////////////////////////////////////////////////
    
    ## =================================
    ## SET UP DATA
    ## =================================

    ## drop missing observations
    dat <- dat %>% filter(!is.na(outcome_var)) %>%filter(group%in%select_group)
    
    ##include only selected institutions
    
    inst_sp<-inst_sp[inst_sp@data$group%in%select_group,]
    
    ## set outcomevar
    
    inst_sp@data$outcome_var<-as.numeric(unlist(inst_sp@data[outcome_var]))
    
    ## Only include complete cases
    
    inst_sp<-inst_sp[is.na(inst_sp@data$outcome_var)==FALSE,]
    
    ## get appropriate shapefile
    county_shape <- readOGR(dsn = ddir,
                            layer = sf,
                            verbose = FALSE)

    ## lower names in attached spatial data
    names(county_shape@data) <- tolower(names(county_shape@data))

    ## drop unnecessary geographic variables to reduce file size
    cols <- c('state','county','name')
    county_shape@data <- county_shape@data[,cols]

    ## create fips from state and county (assumes they are characters)
    county_shape@data$fips <- paste0(county_shape@data$state,
                                     county_shape@data$county)

    ## rename geoid to fips
    ## names(county_shape@data)[names(county_shape@data) == 'geoid'] <- 'fips'

    ## add ACS data
    acsdat$fips <- sprintf('%05s', acsdat$fips)
    county_shape@data <- data.frame(county_shape@data,
                                    acsdat[match(county_shape@data$fips,
                                                 acsdat$fips),])

    ## drop redundant row
    county_shape@data$fips.1 <- NULL
  
    ## correct projection: epsg:4269
    county_shape <- spTransform(county_shape, proj)

    ## simplify to reduce file size
    simple <- gSimplify(county_shape, tol = 0.001, topologyPreserve = TRUE)

    ## need to return spatial dataframe
    county_shape <- SpatialPolygonsDataFrame(simple, data = county_shape@data)

    ## reformat FIPS codes so they have leading zeros
    dat$stfips <- sprintf('%02s', dat$stfips)

    ## subset to states in scorecard data
    county_shape <- county_shape[county_shape@data$state %in% dat$stfips,]

    ## recorrect projection: epsg:4269
    county_shape <- spTransform(county_shape, proj)

    ## =================================
    ## KRIGE OVER AREAS
    ## =================================

    ## inverse distance weighted interpolation
    idw.fit <- idw(outcome_var ~ 1,
                   locations = inst_sp,
                   newdata = county_shape,
                   na.action = na.pass)
    
    ## pull predictions, round, and make integer
    idw.fit.preds <- data.frame(as.integer(round(idw.fit$var1.pred)))
    
    ## get ids and make them rownames
    row.names(idw.fit.preds) <- as.character(county_shape$fips)
    row.names(county_shape) <- as.character(county_shape$fips)
    
    ## column names
    names(idw.fit.preds) <- 'outcome_var'
        
    ## merge back into data frame
    county_shape <- spCbind(county_shape, idw.fit.preds)

    county_shape@data$medinc<-as.numeric(county_shape@data$medinc)
    
    county_shape@data$pctvar<-county_shape@data$outcome_var/county_shape@data$medinc
    
    
    ## =================================
    ## SAVE AND OUTPUT
    ## =================================

    ## map data file ./dir/name
    mapname <- paste0(mdir, 'county_shape_', outcome_var,'_',select_group, '_', year, '.geojson' )
    if(save.file) {
        geojson_write(county_shape, file = mapname)
    }

    ## return spatial data file
    return(county_shape)
}
  


mapSC <- function(countylayer,          # county map data
                  instlayer,            # institution points layer
                  outcome_var,          # scorecard outcome data
                  var_describe          # description for map
                  ) {

    ## ////////////////////////////////////////////////////////////////////
    ## This function produces a leaflet map from the spatial objects
    ## ////////////////////////////////////////////////////////////////////

  ## Take this and make it more complicated: multiple layers to be shown. 
  
  ## Drop Alaska and Hawaii and etc. 
  
  countylayer<-countylayer[!countylayer@data$state%in%c("02","03","14","15","43","52","64","72"),]
  
  
    ## =================================
    ## SET COLORS
    ## =================================

    ## read in diverging palette
    my.colors <- brewer.pal(11,'RdYlGn')

    ## create color ramp (red == bad ---> green == good)
    my.pal <- colorRampPalette(colors = c(my.colors[1],
                                          my.colors[6],
                                          my.colors[11]))(10)
    
    inc_cuts<-base::pretty(x=county_shape@data$outcome_var,n=10)
    
    inc_cuts<-c(inc_cuts,100000,150000)
      
    pct_cuts<-base::pretty(x=county_shape@data$pctvar,n=10)
    
    ## income palette
    inc_pal <- colorQuantile(pal = my.pal,
                             county_shape@data$medinc,
                             n=10
                                )
  ## attendee palette
    attend_pal<-colorQuantile(pal=my.pal,
                              county_shape@data$outcome_var,
                              n=10)
   ## percent palette
   pct_pal  <- colorQuantile(pal = my.pal,
                    county_shape@data$pctvar,
                     n=10)
    
    ## TODO: ALL QUANTILES
                              
                     


    ## =================================
    ## ADJUST LABELS
    ## =================================

    ## split long variable description into 2 if long
    split <- as.integer(length(strsplit(var_describe, ' ')[[1]]) / 2)
    if(split > 1) {
        lo <- split; hi <- split + 1
        legend_title <- strsplit(var_describe, ' ')[[1]]
        legend_title <- paste(paste(legend_title[1:lo], collapse = ' '),
                              '<br/>',
                              paste(legend_title[hi:length(legend_title)],
                                    collapse = ' '), collapse = '')
    } else {
        legend_title <- var_describe
    }

    ## add break and colon to variable description for popup
    var_describe <- paste0('<br/>', var_describe, ': $')
     
    ## =================================
    ## CREATE POPUPS
    ## =================================
       
    county_popup <- paste0(paste0(countylayer@data$name, ' County'),
                           var_describe, 
                           prettyNum(countylayer@data$outcome_var,
                                     big.mark = ',',
                                     scientific = FALSE,
                                     digits = 0),
                           '<br/> County median income: $',
                           prettyNum(countylayer@data$medinc,
                                     big.mark = ',',
                                     scientific = FALSE,
                                     digits = 0),
                           '<br/> Attendee income as % of county income: $',
                           prettyNum(countylayer@data$pctvar,
                                     big.mark = ',',
                                     scientific = FALSE,
                                     digits = 0)
                           )
    
    inst_popup <- paste0(as.character(instlayer@data$instnm),
                         var_describe,
                         prettyNum(instlayer@data$outcome_var,
                                   big.mark = ',',
                                   scientific = FALSE,
                                   digits = 0)
                        )
                             
    ## set bounding box for plotting
    b <- as.vector(bbox(countylayer))
    
    ## expands limits slighlty
    b[1] <- b[1] * 1.03
    b[2] <- b[2] - (b[2] * .03)
    b[3] <- b[3] - (b[3] * .03)
    b[4] <- b[4] * 1.03
   
    ## =================================
    ## CREATE LEAFLET MAP
    ## =================================
    
    county_map <- leaflet(countylayer) %>%
        ## overlay county median income    
        addPolygons(stroke = TRUE,
                    opacity = .25,
                    fill = TRUE,
                    color = ~inc_pal(countylayer@data$medinc),
                    fillOpacity = .65,
                    popup = county_popup,
                    group="County Median Income"
                    ) %>%
      ## overlay county earnings of attendees    
        addPolygons(stroke = TRUE,
                    opacity = .25,
                    fill = TRUE,
                    color = ~attend_pal(countylayer@data$outcome_var),
                    fillOpacity = .65,
                    popup = county_popup,
                    group="Income of Attendees"
                    ) %>%
        ## overlay pct   
        addPolygons(stroke = TRUE,
                    opacity = .25,
                    fill = TRUE,
                    color = ~pct_pal(countylayer@data$pctvar),
                    fillOpacity = .65,
                    popup = county_popup,
                    group="Attendee Income as a % of County Income"
                    ) %>%
        ## legend
        addLegend('bottomleft',
                  pal = attend_pal,
                  title = "Percentiles",
                  values=countylayer@data$outcome_var
                  ) %>%
        ## overlay instititions
        addMarkers(lng = instlayer@coords[,1],
                   lat = instlayer@coords[,2],
                   icon = schoolIcon,
                   pop = inst_popup,
                   group = 'Institutions'
                   ) %>%
        ## layer control for institutions
        addLayersControl(
            overlayGroups = c('Institutions',
                              "County Median Income",
                              "Income of Attendees",
                              "Attendee Income as a % of County Income"
                              ),
            options = layersControlOptions(collapsed = FALSE)
        ) %>%
        ## leave institutions off by default  
        hideGroup('Institutions') %>%
        hideGroup("County Median Income") %>%
        hideGroup( "Attendee Income as a % of County Income")%>%
      
        ## add tiles        
        addProviderTiles('Stamen.TonerLite',
                         options = list(minZoom = 4,
                                        zoom = 4,
                                        maxZoom = 13)
                                                  ) %>%
        ## set boundaries
        setMaxBounds(lng1 = b[1],
                     lat1 = b[2],
                     lng2 = b[3],
                     lat2 = b[4]) 
    ## =================================
    ## RETURN MAP
    ## =================================
    
    return(county_map)
}




countyMapCS <- function(csdat,               # scorecard data
                        instdat,             # institutional data
                        acsdat,              # ACS data
                        outcome_var,         # scorecard outcome variable
                        select_group,        # institutional category
                        proj,                # projection to use
                        redraw_map = FALSE,  # ignore saved kriged map
                        redraw_inst = FALSE, # ignore saved inst. spatial df
                        ...                  # additional arguments
                        ){

    ## ////////////////////////////////////////////////////////////////////
    ## This function is a wrapper for the kriging and mapping functions.
    ## It expects that you have college scorecard data, 
    ## institutional data, shapefile data in the ../data/ directory
    ## ////////////////////////////////////////////////////////////////////

    ## convert outcome column to integer and drop old character version
    suppressWarnings(
        dat <- csdat %>%
            mutate(outcome_var = as.integer(.[[outcome_var]])) %>%
            select_(.dots = c(required, 'outcome_var'))
        )
       
    ## if outcome variable expressed as a proportion change to percent
    if(max(dat$outcome_var, na.rm = TRUE) <= 1){
        dat$outcome_var <- dat$outcome_var * 100
    }

    ## drop states list
    dslist <-  c('AK','AS','DC','FM','GU','HI','MP','PR','PW')

    ## wrangle data
    mapdat <- instdat %>%
        filter(group %in% select_group,                # filter out non-group
               !(stabbr %in% dslist)) %>%              # drop non-lower 48
        select(unitid,
               stfips,
               fips,
               latitude,
               longitud,
               stabbr) %>%                             # subset
        left_join(dat, by = 'unitid') %>%              # join to cs data
        left_join(acs, by = 'fips') %>%                # join to acs data
   #     mutate(pctinc = as.integer(round(outcome_var / medinc * 100))) 
 ##Not what I wanted: wanted county-level, not inst level
      
    ## =================================
    ## READ IN SHAPEFILES
    ## =================================

    ## institutions spatial data file ./dir/name
    instname <-paste0(mdir, 'institutional_points.geojson')
 
    ## institutional data
    if(file.exists(instname) & !(redraw_inst)){
        ## load existing
        inst_sp <- readOGR(instname, layer = 'OGRGeoJSON', verbose = FALSE)
    } else {
        ## create institutional spatial dataframe
        inst_sp <- instPointsSpatial(mapdat, outcome_var, proj)
    }
    
    ## map data file ./dir/name
    mapname <- paste0(mdir, 'county_shape_', outcome_var, '_', year, '.geojson')
    
    if(file.exists(mapname) & !(redraw_map)){
        ## load existing
        county_shape <- readOGR(mapname, layer = 'OGRGeoJSON', verbose = FALSE)
    } else {
        ## create map
        county_shape <- krigeMap(ddir, mapdat, inst_sp, acsdat,
                                 outcome_var, shapefile, proj)
    }

    ## =================================
    ## DRAW AND RETURN MAP
    ## =================================

    out.map <- mapSC(county_shape, inst_sp, outcome_var, var_describe)
    return(out.map)
}
```

```{r makemap}
################################################################################
## MAKE MAP
################################################################################

## Merge IPEDS data with CS data
inst_dat<-left_join(inst_all,csdat,by="unitid")

## Spatial projection of institutions
inst_sp<-instPointsSpatial(dat=inst_dat,
                           proj=CRS('+init=epsg:4269'),
                           save.file=TRUE,
                           outcome_var=outcome
                          )


##separate kriged maps for all 5 institution types
for (i in 1:5){
  krigeMap(dat=inst_dat,
           inst_sp=inst_sp,
           acsdat=acs,
           select_group=i,
           outcome_var=outcome,
           sf=county_layer,
           ddir = "../data/"
           )
}

## Now generate maps for each

mapname <- paste0(mdir, 'county_shape_', outcome_var, '_', i,"_",year, '.geojson')
     
county_shape <- readOGR(mapname, layer = 'OGRGeoJSON', verbose = FALSE)

county_shape@data$pctvar<-county_shape@data$outcome_var/as.numeric(county_shape@data$medinc)

```

<!--

HTML page content

-->

The map below displays county level estimates of the earnings among working
attendees of local public two-year colleges ten years after first
attendance. The map is interactive: click on any county for county-level
estimate. Zoom using "+/-" in upper left corner. Pan using mouse or
keyboard arrows. Check "institutions" box to see institutional
location. Click on institutions to see scorecard data for that
institution.

## County Level Estimates: Earnings of Public Two-Year Attendees Ten Years After Entry

```{r printmap, results = 'show', fig.width = 9.5}
################################################################################
## PRINT MAP
################################################################################

county_map_earn
```

## Notes

The data only include attendees who took some form of federal
financial aid (loans or grants). County-level estimates are based on
the distance-weighted measures for nearby institutions, with nearest
institutions weighted highest. 

## Data

### Median income 10 years after first enrollment

The primary income data come from college scorecard dataset:
[https://collegescorecard.ed.gov/data/](https://collegescorecard.ed.gov/data/).
The variable used is **`r outcome`**. Data are from the year 2011.

### County median income

Median income data come from the American Community Survey 3-year
rolling estimates. The table id is **S19013**. The years surrounding
2011 were used (2010-2012). Data from the table are in the GitHub
respository, but the full table can be
[downloaded here](http://factfinder.census.gov/faces/tableservices/jsf/pages/productview.xhtml?pid=ACS_12_3YR_S1903&prodType=table).

### Spatial polygons

Spatial shapefiles were taken from the [U.S. Census Bureau Cartographic
Boundary Shapefiles](https://www.census.gov/geo/maps-data/data/cbf/cbf_counties.html).
Specifically, the 500k resolution files were used. These contain fewer
details than finer featured TIGER shapefiles, but are much smaller and
are adequate for this map.

## Download, fork, or collaborate

The GitHub repository for this project may be found at
[https://github.com/wdoyle42/scorecard](https://github.com/wdoyle42/scorecard).

This is an ongoing project. Comments welcome, better code even more so.

## Authors

Will Doyle: [Website](https://my.vanderbilt.edu/willdoyle/),
[GitHub](https://github.com/wdoyle42)  
Benjamin Skinner: [Website](http://btskinner.me/), [GitHub](https://github.com/btskinner)
